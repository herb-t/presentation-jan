<!doctype html>
<html class="no-js">
  <head>
    <meta charset="utf-8">
    <title>Sorting Algorithms</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <link rel="icon" href="images/favicon.png">
    <link href='https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="css/index.css">



  </head>
  <body>
    <div id="overlay"></div>

    <svg version="1.1" id="logo" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
       viewBox="0 0 88 131" style="enable-background:new 0 0 88 131;" xml:space="preserve">
      <style type="text/css">
        .st0{fill:#EE1D54;}
      </style>
      <g>
        <g>
          <path class="st0" d="M63.7,0.1L63.7,0.1C44.3,0.1,44.3,14.9,44.3,24v14.7c0,9.1,0,23.9,19.3,23.9h0C83,62.7,83,47.9,83,38.7V24
            C83,14.9,83,0.1,63.7,0.1z M68.2,42.2c0,2.2,0,5.7-4.6,5.7s-4.6-3.5-4.6-5.7V20.6c0-2.2,0-5.7,4.6-5.7s4.6,3.5,4.6,5.7V42.2z"/>
          <path class="st0" d="M24,1.2v21.6c0,0.7-0.5,1.2-1.2,1.2h-6.9c-0.7,0-1.2-0.5-1.2-1.2V1.2c0-0.7-0.5-1.2-1.2-1.2H1.2
            C0.5,0,0,0.5,0,1.2V24v14.8v22.7c0,0.7,0.5,1.2,1.2,1.2h12.3c0.7,0,1.2-0.5,1.2-1.2V39.9c0-0.7,0.5-1.2,1.2-1.2h6.9
            c0.7,0,1.2,0.5,1.2,1.2v21.6c0,0.7,0.5,1.2,1.2,1.2h12.3c0.7,0,1.2-0.5,1.2-1.2V38.8V24V1.2c0-0.7-0.5-1.2-1.2-1.2H25.2
            C24.5,0,24,0.5,24,1.2z"/>
        </g>
        <path class="st0" d="M19.3,68.5L19.3,68.5C0,68.5,0,83.2,0,92.4v14.7c0,9.1,0,23.9,19.3,23.9h0c19.3,0,19.3-14.7,19.3-23.9V92.4
          C38.7,83.2,38.7,68.5,19.3,68.5z M23.9,110.5c0,2.2,0,5.7-4.6,5.7h0c-4.6,0-4.6-3.5-4.6-5.7V88.9c0-2.2,0-5.7,4.6-5.7h0
          c4.6,0,4.6,3.5,4.6,5.7V110.5z"/>
        <path class="st0" d="M72.5,131H87c0.8,0,1.3-0.8,0.9-1.5l-15.8-29.3c-0.1-0.3-0.2-0.6,0-0.9l12.5-29.6c0.3-0.7-0.2-1.4-0.9-1.4
          H69.8c-0.4,0-0.8,0.2-0.9,0.6l-9.2,21.8C59.5,91.1,59,91,59,90.6V69.4c0-0.6-0.5-1-1-1H45.3c-0.6,0-1,0.5-1,1V130c0,0.6,0.5,1,1,1
          H58c0.6,0,1-0.5,1-1v-21.6c0-0.4,0.5-0.5,0.6-0.2l12,22.3C71.8,130.8,72.1,131,72.5,131z"/>
      </g>
    </svg>


    <div class="reveal">
      <div class="slides">
        
        <!-- slide -->
        <section>
          <h1>Javascript Algorithms</h1>
          <h2>Sorting</h2>
        </section>
        
        <!-- slide -->
        <section>
          <h2>Javascript Sorting Algorithms</h2>
          <p>Sorting algorithms are used widely to organize sets of information that have been stored in data structures.  There are many different sorting algorithms, each differ in their methods to sort the data as well as their efficiency and performance.  The type of data in your data structures will dictate the sorting algorithm you should use.  In some cases, writing your own is the best approach.</p>
          <p>Lets not forget that the native method <strong style="color: #FF0050;">Array.prototype.sort()</strong> will do the right thing and provide the fastest possible implementation. Let's take a look at some of the more popular and widely used sorting algorithms to see the difference in methodology and performance.  Bubble Sort, Merge Sort and Quick Sort.</p>
        </section>

        <!-- slide -->
        <!-- <section>
          <h2>Bubble Sort</h2>
          <p>The bubble sort algorithm simply goes down the array and compares the first item of the array with the second.  If the first item is bigger than the second item, the algorithm swaps them so the bigger one stays in the second position.  This keeps happening until the you reach the last item of the array.  So with the bubble sorting algorithm, we “bubble” up the biggest item of the array to the right most position of the array.</p>
        </section> -->

        <!-- slide -->
        <!-- <section>
          <h2>Bubble Sort</h2>
          <p class="align-center">Let’s take a look how merge sorting would look through this array and reposition the items.</p>
          <img src="images/gif-bubble.gif" alt="Bubble Sort Gif" class="gif-eg">
          <br>
          <br>
          <p class="align-center">As you can see, this is probably the worst way to sort through our data but a good algorithm to start with.</p>
        </section> -->
        <section>
          <h2>Bubble Sort</h2>
         <!--  <p>This one is simple enough to list out the procedure.</p> -->
         <!--  <p>Lets take an unsorted array:  <strong>[4,0,2,3,1]</strong></p>
          <ul>
            <li>[<strong>0</strong>,<strong>4</strong>,2,3,1]</li>
            <li>[0,<strong>2</strong>,<strong>4</strong>,3,1]</li>
            <li>[0,2,<strong>3</strong>,<strong>4</strong>,1]</li>
            <li>[0,2,3,<strong>1</strong>,<strong>4</strong>]</li>
            <li>[0,2,<strong>1</strong>,<strong>3</strong>,4]</li>
            <li>[0,<strong>1</strong>,<strong>2</strong>,3,4]</li>
          </ul> -->
          <p class="align-center">Let’s take a look how bubble sorting would look through this array and reposition the items.</p>
          <img src="images/gif-bubble.gif" alt="Bubble Sort Gif" class="gif-eg">
          <br>
          <br>
          <p class="align-center">As you can see, this is probably the worst way to sort through our data but a good algorithm to start with.</p>
          <span>Let's see it in action: <a href="http://codepen.io/herbicus/pen/vLJpwz" target="_blank">http://codepen.io/herbicus/pen/vLJpwz</a></span>
        </section>

        <!-- slide -->
        <!-- <section>
          <h2>Bubble Sort</h2>
          <p>This one is simple enough to list out the procedure.</p>
          <p>Lets take an unsorted array:  <strong>[4,0,2,3,1]</strong></p>
          <ul>
            <li>[<strong>0</strong>,<strong>4</strong>,2,3,1]</li>
            <li>[0,<strong>2</strong>,<strong>4</strong>,3,1]</li>
            <li>[0,2,<strong>3</strong>,<strong>4</strong>,1]</li>
            <li>[0,2,3,<strong>1</strong>,<strong>4</strong>]</li>
            <li>[0,2,<strong>1</strong>,<strong>3</strong>,4]</li>
            <li>[0,<strong>1</strong>,<strong>2</strong>,3,4]</li>
          </ul>
          <br>
          <br>
          <span>Let's see it in action: <a href="http://codepen.io/herbicus/pen/vLJpwz" target="_blank">http://codepen.io/herbicus/pen/vLJpwz</a></span>         
        </section> -->

        <!-- slide -->
        <section>
          <h2>Merge Sort</h2>
          <p>The merge sort is a divide and conquer algorithm. The idea behind it is to divide the original array into smaller arrays until each small array has only one position and then merge these smaller arrays into bigger ones until we have a single big array at the end that is sorted.  Merge sort will transform a bigger array into a smaller array until they have only one item in them.</p>
        </section>

        <!-- slide -->
        <section>
          <h2>Merge Sort</h2>
          <p class="align-center">Let’s take a look how merge sorting would look through this array and reposition the items.</p>
          <img src="images/gif-merge.gif" alt="Merge Sort Gif" class="gif-eg">
          <br>
          <br>
          <!-- <p class="align-center">Slightly more complex than Bubble Sort but a lot more efficient.</p> -->
          <p class="align-center"><p>We’ll need two functions to accomplish this.  One function will transform a bigger array into smaller arrays until they have only one item in them.  As the algorithm is recursive, we need a stop condition or a helper function.  This function receives two arrays and merges them into a bigger array. At the end, we return a merged array as the result.</p></p>
          <span class="align-center">Let's see it in action: <a href="http://codepen.io/herbicus/pen/WrEmbj" target="_blank">http://codepen.io/herbicus/pen/WrEmbj</a></span>
        </section>

        <!-- slide -->
        <!-- <section >
          <h2>Merge Sort</h2>

          <p>We’ll need two functions to accomplish this.  One function will transform a bigger array into smaller arrays until they have only one item in them.  As the algorithm is recursive, we need a stop condition or a helper function.  This function receives two arrays and merges them into a bigger array. At the end, we return a merged array as the result.</p>
          <br><br>
          <span>Let's see it in action: <a href="http://codepen.io/herbicus/pen/WrEmbj" target="_blank">http://codepen.io/herbicus/pen/WrEmbj</a></span>         
        </section> -->

        <!-- slide -->
        <section >
          <h2>Quick Sort</h2>
          <p>The quick sort is probably the most used sorting algorithm.  Like the merge sort, it also uses the divide and conquer approach, dividing the original array into smaller ones (but without splitting them as the merge sort does) to do the sorting. The quick sort algorithm is a little bit more complex than the other ones.</p>
        </section>

        <!-- slide -->
        <section >
          <h2>Quick Sort</h2>
          <p>Lets break down the process into steps:</p>
        
          <ol>
            <br>
            <li>First, we need to select an item from the array that is called as a pivot.  It can be random but it makes sense to go with the middle item or the last item of the array.</li>
            <br>
            <li>We will create two pointers.  The left one will point to the first item of the array and the right one will point to the last item of the array.  We will move the left pointer until we find an item that is bigger than the pivot and we will also move the right pointer until we find an item that is less than the pivot and we will swap them.  We repeat this process until the left pointer passes the right pointer.  This process helps to have values lower than the pivot before the pivot and values greater than the pivot after the pivot.  This is called partition operation.</li>
            <br>
            <li>Next the algorithm repeats the previous two steps for smaller arrays  (sub-arrays with smaller values, and then sub-arrays with greater values) until the array is completely sorted.</li>
          </ol>
        
        </section>

        <!-- slide -->
        <section>
          <h2>Quick Sort</h2>
          <p>Let’s take a look how quick sorting would look through this <strong style="color: #FF0050;">array</strong> and reposition the items.  In this demo, <strong style="color: #FF0050;">3</strong> is our starting pivot point.</p>
          <img src="images/gif-quick.gif" alt="Quick Sort Gif" class="gif-eg">
          <br>
          <br>
          <p>As you can see, Quick Sorting is quite complex but a very efficient algorithm.</p>
        </section>

        <!-- slide -->
        <section>
          <h2>Quick Sort</h2>

          <p>There's lots going on lets talk about the code a bit first:</p>
        
          <dl>
            <br>
            <dt>Call Quick sort</dt>
            <dd>Pass the array and pass left and right to the quickSort function. For the first call, left would be the index of the first element which is 0 and right would be the index of the last element which would be length -1.</dd>
            <br>
            <dt>Select Pivot</dt>
            <dd>We select pivot as the last index of the array.</dd>
            <br>
            <dt>Call Partition funtion</dt>
            <dd>After calculating the pivot, we send the pivot to the partition function. In the partition function we pass array, pivot index, left and right.</dd>
            <br>
            <dt>partitionIndex variable</dt>
            <dd>In the partition function, we keep move all the items smaller than the pivot value to the left and larger than pivot value to the right. We have to keep track of the position of the partition. so that we can split the array into two parts in the next step. This tracking of the index where we partition the array is done by using partitionIndex variable. the initial value is left.</dd>
            <br>
            <dt>Swap function</dt>
            <dd>This is just a helper function to swap values of the array.</dd>
          </dl>
          
              
        </section>

        <!-- slide -->
        <section>
          <h2>Quick Sort</h2>
         
          <dl>
            <dt>Move elements</dt>
            <dd>we start a for loop from the left, and if the values is smaller than the pivot values we swap it with the position of the partitionIndex and increase the value of the partitionIndex. If the value is bigger, we don't do anything. We keep going until the element before the last element (remember last element is the pivot).</dd>
            <br>
            <dt>Place pivot</dt>
            <dd> After moving all the smallest element to the left, we swap the last element (pivot value) with the partitionIndex. By doing this, the pivot sits where it suppose to sit when the full array is sorted. As all elements left to it smaller and all element right to it is bigger. End of the function partition, return the partitionIndex.</dd>
            <br>
            <dt>Repeat the process</dt>
            <dd>Now come back to quickSort function. when you get the partitionIndex, apply quickSort for the left side of the array and right side of the array. keep doing it until left is smaller than right.</dd>
          </dl>
         
          <br><br>
          <span>Let's see it in action: <a href="http://codepen.io/herbicus/pen/yeorGN" target="_blank">http://codepen.io/herbicus/pen/yeorGN</a></span>         
        </section>

        <!-- slide -->
        <section>
          <h2>Lets Make It Fun</h2>
          <p>So far, we've seen these algorithms in action using arrays of numbers.  Boring!  Lets take a look at something a little more practical.</p>

          <a href="#">A link to a fun codepen here</a>
        </section>
      
      </div>
    </div>

    <script src="js/vendor.js"></script>
    <script src="js/main.build.js"></script>
  </body>
</html>
